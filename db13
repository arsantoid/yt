#!/bin/bash

# ===================================================================
#   SETUP SCRIPT YTLIVE STREAMER (v30 - STABIL COPY MODE DEBIAN 11/13)
# ===================================================================

set -e  # Hentikan skrip jika ada error

# --- Variabel Konfigurasi ---
PYTHON_SCRIPT_NAME="ytlive"
PYTHON_SCRIPT_PATH="/usr/local/bin/${PYTHON_SCRIPT_NAME}"
WORKER_SCRIPT_PATH="/usr/local/bin/ytlive-worker.sh"
CHANNELS_BASE_DIR="/root/data/channels"
SERVICE_USER="ytlive"
SERVICE_GROUP="ytlive"
FFMPEG_JV_DIR="/opt/ffmpeg-johnvansickle"

# --- Fungsi Logging ---
log_info()  { echo -e "\e[32m[INFO]\e[0m $1"; }
log_warn()  { echo -e "\e[33m[PERINGATAN]\e[0m $1"; }
log_error() { echo -e "\e[31m[ERROR]\e[0m $1"; exit 1; }

# --- 1. Konfigurasi Sistem ---
log_info "Mengatur zona waktu dan memperbarui paket..."
timedatectl set-timezone Asia/Jakarta || log_warn "Gagal mengatur zona waktu."
apt-get update -y >/dev/null || log_error "Gagal memperbarui daftar paket."

log_info "Menginstal dependensi dasar..."
apt-get install -y \
  python3 python3-pip python3-psutil python3-requests \
  wget tar xz-utils acl logrotate || \
  log_error "Gagal menginstal dependensi dasar."

log_info "Menginstal PolicyKit yang kompatibel..."
if apt-get install -y policykit-1 2>/dev/null; then
  log_info "policykit-1 terinstal (mode Debian 11/legacy)."
else
  log_info "policykit-1 tidak ada, pakai polkitd + pkexec (Debian 13+)."
  apt-get install -y polkitd pkexec || log_error "Gagal menginstal polkitd/pkexec."
fi

# --- 2. Bersihkan komponen lama yang akan diganti ---
log_info "Membersihkan unit systemd & skrip lama..."
rm -f /etc/systemd/system/ytlive-stream@.service
rm -f /etc/systemd/system/ytlive-schedule-start@.service
rm -f /etc/systemd/system/ytlive-schedule-stop@.service
rm -f /etc/sudoers.d/ytlive
rm -f /etc/logrotate.d/ytlive
rm -f "${PYTHON_SCRIPT_PATH}"
rm -f "${WORKER_SCRIPT_PATH}"

# --- 3. FFMPEG: pakai versi APT yang stabil ---
log_info "Menginstal FFMPEG dari repository Debian..."
# Jika sebelumnya ada ffmpeg John, putuskan symlink tapi biarkan foldernya
if [ -L /usr/bin/ffmpeg ] && readlink /usr/bin/ffmpeg | grep -q "ffmpeg-johnvansickle"; then
  rm -f /usr/bin/ffmpeg /usr/bin/ffprobe
fi
apt-get install -y ffmpeg || log_error "Gagal menginstal ffmpeg dari APT."
FFMPEG_BIN="/usr/bin/ffmpeg"

# --- 4. Direktori & user service ---
log_info "Menyiapkan direktori channel & user service..."
mkdir -p "${CHANNELS_BASE_DIR}"
id -g "${SERVICE_GROUP}" &>/dev/null || groupadd "${SERVICE_GROUP}"
id -u "${SERVICE_USER}" &>/dev/null || useradd -r -s /bin/false -g "${SERVICE_GROUP}" "${SERVICE_USER}"
chown -R "${SERVICE_USER}:${SERVICE_GROUP}" "${CHANNELS_BASE_DIR}"
setfacl -m u:${SERVICE_USER}:x /root       &>/dev/null || true
setfacl -m u:${SERVICE_USER}:x /root/data  &>/dev/null || true

# --- 5. Aturan sudo untuk start/stop service ---
log_info "Membuat aturan sudo untuk ytlive..."
cat << EOF > /etc/sudoers.d/ytlive
ytlive ALL=(ALL) NOPASSWD: /bin/systemctl start ytlive-*, /bin/systemctl stop ytlive-*
EOF
chmod 0440 /etc/sudoers.d/ytlive

# --- 6. Logrotate ---
log_info "Mengkonfigurasi logrotate..."
cat << EOF > /etc/logrotate.d/ytlive
/root/data/channels/*/stream.log {
    daily
    rotate 7
    missingok
    notifempty
    compress
    delaycompress
    copytruncate
}
EOF

# --- 7. Skrip worker bash ---
log_info "Membuat worker script ${WORKER_SCRIPT_PATH}..."
cat << EOF > "${WORKER_SCRIPT_PATH}"
#!/bin/bash
set -e
CHANNEL_NAME=\$1
exec \$(/usr/bin/python3 ${PYTHON_SCRIPT_PATH} _internal_get_ffmpeg_cmd "\$CHANNEL_NAME") &>> stream.log
EOF
chmod +x "${WORKER_SCRIPT_PATH}"

# --- 8. Unit systemd template ---
log_info "Membuat unit systemd template..."
cat << EOF > /etc/systemd/system/ytlive-stream@.service
[Unit]
Description=YTLive Streamer for %i
StartLimitIntervalSec=500
StartLimitBurst=5

[Service]
User=${SERVICE_USER}
Group=${SERVICE_GROUP}
WorkingDirectory=${CHANNELS_BASE_DIR}/%i
ExecStart=${WORKER_SCRIPT_PATH} %i
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

cat << EOF > /etc/systemd/system/ytlive-schedule-start@.service
[Unit]
Description=Scheduled start for YTLive channel %i
[Service]
Type=oneshot
User=${SERVICE_USER}
ExecStart=${PYTHON_SCRIPT_PATH} start %i
EOF

cat << EOF > /etc/systemd/system/ytlive-schedule-stop@.service
[Unit]
Description=Scheduled stop for YTLive channel %i
[Service]
Type=oneshot
User=${SERVICE_USER}
ExecStart=${PYTHON_SCRIPT_PATH} stop %i
EOF

systemctl daemon-reload

# --- 9. CLI Python ytlive (mode A/B full copy) ---
log_info "Menulis skrip manajemen Python ke ${PYTHON_SCRIPT_PATH}..."
cat << 'EOF' > "${PYTHON_SCRIPT_PATH}"
#!/usr/bin/env python3
import os
import sys
import subprocess
import argparse
import shlex
from pathlib import Path
from datetime import datetime, timedelta
import shutil

# ===================== KONFIGURASI =========================
CHANNELS_DIR    = Path("/root/data/channels")
YOUTUBE_RTMP_URL = "rtmp://a.rtmp.youtube.com/live2"
AUDIO_BITRATE   = "128k"
SERVICE_USER    = "ytlive"
SERVICE_GROUP   = "ytlive"
LIFETIME_TAG    = "# LIFETIME_STREAM"
FFMPEG_PATH     = "/usr/bin/ffmpeg"
SYSTEMD_DIR     = Path("/etc/systemd/system")
# ==========================================================

COLOR_RESET = "\033[0m"
COLOR_INFO  = "\033[0;32m"
COLOR_WARN  = "\033[0;33m"
COLOR_ERROR = "\033[0;31m"
COLOR_CYAN  = "\033[0;36m"
COLOR_STATUS_RUNNING = COLOR_INFO
COLOR_STATUS_STOPPED = COLOR_WARN
COLOR_STATUS_CRASH   = COLOR_ERROR

def print_info(msg):  print(f"{COLOR_INFO}[INFO]{COLOR_RESET} {msg}")
def print_warn(msg):  print(f"{COLOR_WARN}[PERINGATAN]{COLOR_RESET} {msg}")
def print_error(msg): print(f"{COLOR_ERROR}[ERROR]{COLOR_RESET} {msg}")

def _get_paths(name):
    d = CHANNELS_DIR / name
    return {
        "dir": d,
        "lock": d / ".stream.lock",
        "log": d / "stream.log",
        "key": d / "stream_key.txt",
    }

def _get_channel_mode(paths):
    if not paths["dir"].is_dir():
        return "N/A"
    videos = list(paths["dir"].glob("*.mp4")) + list(paths["dir"].glob("*.mkv"))
    if not videos or any(v.stat().st_size == 0 for v in videos):
        return "N/A (Video Kosong)"
    audios = (list(paths["dir"].glob("*.mp3"))
              + list(paths["dir"].glob("*.m4a"))
              + list(paths["dir"].glob("*.aac")))
    if audios:
        return "B (Video + Audio Harian)"
    return "A (Video Saja)"

def _build_ffmpeg_command(paths, mode):
    if not paths["key"].is_file() or paths["key"].stat().st_size == 0:
        return None
    key = paths["key"].read_text().strip()
    videos = sorted(list(paths["dir"].glob("*.mp4")) + list(paths["dir"].glob("*.mkv")))
    if not videos:
        return None
    day_of_year = datetime.now().timetuple().tm_yday
    video = videos[(day_of_year - 1) % len(videos)]

    # Base: realtime + loop video, TANPA filter tambahan
    if mode == "A (Video Saja)":
        cmd = [
            FFMPEG_PATH,
            "-re",
            "-stream_loop", "-1",
            "-i", str(video),
            "-c:v", "copy",
            "-c:a", "copy",
            "-f", "flv",
            f"{YOUTUBE_RTMP_URL}/{key}",
        ]
        return cmd

    elif mode == "B (Video + Audio Harian)":
        audios = sorted(list(paths["dir"].glob("*.mp3")) +
                        list(paths["dir"].glob("*.m4a")) +
                        list(paths["dir"].glob("*.aac")))
        if not audios:
            return None
        audio = audios[(day_of_year - 1) % len(audios)]

        # Audio: kalau m4a/aac -> copy, kalau mp3 -> transcode ke aac
        audio_codec = []
        if audio.suffix.lower() in [".m4a", ".aac"]:
            audio_codec = ["-c:a", "copy"]
        else:
            audio_codec = ["-c:a", "aac", "-b:a", AUDIO_BITRATE]

        cmd = [
            FFMPEG_PATH,
            "-re",
            "-stream_loop", "-1",
            "-i", str(video),
            "-stream_loop", "-1",
            "-i", str(audio),
            "-map", "0:v:0",
            "-map", "1:a:0",
            "-c:v", "copy",
            *audio_codec,
            "-f", "flv",
            f"{YOUTUBE_RTMP_URL}/{key}",
        ]
        return cmd

    return None

def handle_start(args):
    paths = _get_paths(args.channel)
    if not paths["dir"].is_dir():
        return print_error(f"Channel '{args.channel}' tidak ditemukan.")
    if subprocess.run(["systemctl", "is-active", "--quiet",
                       f"ytlive-stream@{args.channel}.service"]).returncode == 0:
        return print_warn(f"Service untuk '{args.channel}' sudah berjalan.")
    paths["lock"].write_text(LIFETIME_TAG)
    try:
        subprocess.run(
            ["sudo", "systemctl", "start", f"ytlive-stream@{args.channel}.service"],
            check=True
        )
        print_info(f"Streaming '{args.channel}' dimulai via systemd.")
    except subprocess.CalledProcessError:
        print_error(f"Gagal memulai service. Cek log dengan: ytlive debug {args.channel}")

def handle_stop(args, quiet=False):
    subprocess.run(
        ["sudo", "systemctl", "stop", f"ytlive-stream@{args.channel}.service"],
        check=False,
        capture_output=True,
    )
    paths = _get_paths(args.channel)
    paths["lock"].unlink(missing_ok=True)
    if not quiet:
        print_info(f"Stream '{args.channel}' dihentikan.")

def handle_list(args):
    print(f"{'NAMA CHANNEL':<25} {'MODE':<28} {'STATUS':<20} {'JADWAL'}")
    print("-" * 100)
    if not CHANNELS_DIR.is_dir():
        return
    timers_output = subprocess.run(
        ["systemctl", "list-timers", "ytlive-schedule-*", "--no-legend", "--all"],
        capture_output=True,
        text=True,
    ).stdout
    timers = [line.split() for line in timers_output.splitlines()
              if "ytlive-schedule" in line]

    for d in sorted(CHANNELS_DIR.iterdir()):
        if not d.is_dir():
            continue
        ch_name = d.name
        paths = _get_paths(ch_name)
        mode = _get_channel_mode(paths)
        status = f"{COLOR_STATUS_STOPPED}[ STOPPED ]{COLOR_RESET}"
        jadwal = "Manual"

        start_timer = next((t for t in timers
                            if f"ytlive-schedule-start@{ch_name}.timer" in t), None)
        stop_timer = next((t for t in timers
                           if f"ytlive-schedule-stop@{ch_name}.timer" in t), None)
        is_scheduled = bool(start_timer and stop_timer)

        if subprocess.run(["systemctl", "is-active", "--quiet",
                           f"ytlive-stream@{ch_name}.service"]).returncode == 0:
            status = f"{COLOR_STATUS_RUNNING}[ RUNNING ]{COLOR_RESET}"
        elif paths["lock"].exists() and not is_scheduled:
            status = f"{COLOR_STATUS_CRASH}[  CRASH  ]{COLOR_RESET}"

        if is_scheduled:
            try:
                st = start_timer[2]
                et = stop_timer[2]
                st_hm = datetime.strptime(st, "%H:%M:%S").strftime("%H:%M")
                et_hm = datetime.strptime(et, "%H:%M:%S").strftime("%H:%M")
                jadwal = f"{st_hm} - {et_hm}"
            except Exception:
                jadwal = "Terjadwal (?)"
        elif paths["lock"].exists():
            jadwal = "Manual/Lifetime"

        print(f"{ch_name:<25} {COLOR_CYAN}{mode:<28}{COLOR_RESET} {status:<20} {jadwal}")
    print("-" * 100)

def handle_timers(args):
    print_info("Menampilkan jadwal timer systemd untuk YTLive...")
    print("-" * 70)
    subprocess.run(["systemctl", "list-timers", "ytlive-schedule-*", "--no-pager"])
    print("-" * 70)

def handle_create(args):
    paths = _get_paths(args.channel)
    if paths["dir"].exists():
        print_info(f"Channel '{args.channel}' sudah ada.")
        return
    paths["dir"].mkdir(parents=True, exist_ok=True)
    paths["key"].touch()
    subprocess.run(["chown", "-R", f"{SERVICE_USER}:{SERVICE_GROUP}", str(paths["dir"])])
    print_info(f"Channel '{args.channel}' dibuat di: {paths['dir']}")

def handle_delete(args):
    paths = _get_paths(args.channel)
    if not paths["dir"].exists():
        return print_error(f"Channel '{args.channel}' tidak ditemukan.")
    handle_stop(args, quiet=True)
    handle_unschedule(args, quiet=True)
    ans = input(f"{COLOR_WARN}Anda yakin ingin menghapus '{args.channel}'? Ketik 'DELETE': {COLOR_RESET}")
    if ans == "DELETE":
        shutil.rmtree(paths["dir"])
        print_info(f"Channel '{args.channel}' dihapus.")

def handle_log(args):
    log_file = _get_paths(args.channel)["log"]
    if not log_file.exists():
        return print_info(f"Log file untuk '{args.channel}' tidak ditemukan.")
    print(f"-> Menampilkan log untuk '{args.channel}' (Ctrl+C untuk keluar)...")
    try:
        with subprocess.Popen(["tail", "-f", str(log_file)]) as proc:
            proc.wait()
    except KeyboardInterrupt:
        print("\nKeluar dari mode log.")

def handle_status(args):
    paths = _get_paths(args.channel)
    if not paths["dir"].is_dir():
        return print_error(f"Channel '{args.channel}' tidak ditemukan.")
    print("-" * 60)
    print(f"Status Detail untuk Channel: {COLOR_CYAN}{args.channel}{COLOR_RESET}")
    mode = _get_channel_mode(paths)
    print(f"  - Mode             : {mode}")
    status_str = f"{COLOR_STATUS_STOPPED}STOPPED{COLOR_RESET}"
    if (SYSTEMD_DIR / f"ytlive-stream@{args.channel}.service").exists():
        if subprocess.run(["systemctl", "is-active", "--quiet",
                           f"ytlive-stream@{args.channel}.service"]).returncode == 0:
            status_str = f"{COLOR_STATUS_RUNNING}RUNNING{COLOR_RESET}"
        elif paths["lock"].exists():
            status_str = f"{COLOR_STATUS_CRASH}CRASHED{COLOR_RESET}"
    print(f"  - Status Service   : {status_str}")
    print("  - Log Terakhir     :")
    if not paths["log"].exists():
        print("    (Log file tidak ditemukan)")
    else:
        try:
            lines = paths["log"].read_text().splitlines()[-15:]
            for line in lines:
                print(f"    {line}")
        except Exception as e:
            print(f"    (Gagal membaca log: {e})")
    print("-" * 60)

def handle_debug(args):
    service = f"ytlive-stream@{args.channel}.service"
    print("-" * 60)
    print(f"Menampilkan log systemd untuk: {COLOR_CYAN}{service}{COLOR_RESET}")
    print("-" * 60)
    try:
        subprocess.run(["journalctl", "-u", service, "-f", "--no-pager"])
    except KeyboardInterrupt:
        print("\nKeluar dari mode debug.")
    print("-" * 60)

def _clean_single_channel(name, quiet=False):
    paths = _get_paths(name)
    if subprocess.run(["systemctl", "is-active", "--quiet",
                       f"ytlive-stream@{name}.service"]).returncode == 0:
        if not quiet:
            print_warn(f"Melewatkan pembersihan '{name}' karena sedang berjalan.")
        return False
    if not quiet:
        print_info(f"Membersihkan file sementara untuk '{name}'...")
    for f in [paths["log"], paths["lock"]]:
        if f.exists():
            f.unlink()
            if not quiet:
                print(f"  -> Dihapus: {f.name}")
    return True

def handle_schedule(args):
    _clean_single_channel(args.channel, quiet=True)
    paths = _get_paths(args.channel)
    mode = _get_channel_mode(paths)
    if "N/A" in mode:
        return print_error(f"Mode channel tidak valid atau file media kosong. Mode: '{mode}'")
    try:
        start_dt = datetime.strptime(args.start_time, "%H:%M")
        stop_dt = (datetime.strptime(args.stop_time, "%H:%M")
                   if args.stop_time else
                   start_dt + timedelta(hours=17, minutes=59))
    except ValueError:
        return print_error("Format waktu salah. Gunakan HH:MM, contoh 08:00 atau 21:30")
    handle_unschedule(args, quiet=True)
    paths["lock"].unlink(missing_ok=True)
    ch = args.channel
    start_cal = f"*-*-* {start_dt.strftime('%H:%M:%S')}"
    stop_cal  = f"*-*-* {stop_dt.strftime('%H:%M:%S')}"
    (SYSTEMD_DIR / f"ytlive-schedule-start@{ch}.timer").write_text(
        f"[Unit]\nDescription=Timer to start YTLive channel {ch}\n"
        f"[Timer]\nOnCalendar={start_cal}\nPersistent=true\n"
        f"Unit=ytlive-schedule-start@{ch}.service\n"
        f"[Install]\nWantedBy=timers.target\n"
    )
    (SYSTEMD_DIR / f"ytlive-schedule-stop@{ch}.timer").write_text(
        f"[Unit]\nDescription=Timer to stop YTLive channel {ch}\n"
        f"[Timer]\nOnCalendar={stop_cal}\nPersistent=true\n"
        f"Unit=ytlive-schedule-stop@{ch}.service\n"
        f"[Install]\nWantedBy=timers.target\n"
    )
    try:
        subprocess.run(["systemctl", "daemon-reload"], check=True)
        subprocess.run(["systemctl", "enable",
                        f"ytlive-schedule-start@{ch}.timer",
                        f"ytlive-schedule-stop@{ch}.timer"],
                       check=True, capture_output=True)
        subprocess.run(["systemctl", "start",
                        f"ytlive-schedule-start@{ch}.timer",
                        f"ytlive-schedule-stop@{ch}.timer"],
                       check=True, capture_output=True)
        print_info(f"Jadwal '{ch}' diatur: {start_dt.strftime('%H:%M')} - {stop_dt.strftime('%H:%M')}")
    except subprocess.CalledProcessError as e:
        print_error(f"Gagal mengatur timer systemd: {e}")

def handle_unschedule(args, quiet=False):
    ch = args.channel
    start_timer = SYSTEMD_DIR / f"ytlive-schedule-start@{ch}.timer"
    stop_timer  = SYSTEMD_DIR / f"ytlive-schedule-stop@{ch}.timer"
    if not start_timer.exists():
        if not quiet:
            print_info(f"Tidak ada jadwal untuk '{ch}'.")
        return
    subprocess.run(["systemctl", "stop",
                    f"ytlive-schedule-start@{ch}.timer",
                    f"ytlive-schedule-stop@{ch}.timer"],
                   capture_output=True, check=False)
    subprocess.run(["systemctl", "disable",
                    f"ytlive-schedule-start@{ch}.timer",
                    f"ytlive-schedule-stop@{ch}.timer"],
                   capture_output=True, check=False)
    start_timer.unlink(missing_ok=True)
    stop_timer.unlink(missing_ok=True)
    subprocess.run(["systemctl", "daemon-reload"], capture_output=True, check=False)
    if not quiet:
        print_info(f"Jadwal untuk '{ch}' dihapus.")

def handle_clean(args):
    if args.channel.lower() == "all":
        for d in CHANNELS_DIR.iterdir():
            if d.is_dir():
                _clean_single_channel(d.name)
    else:
        _clean_single_channel(args.channel)

def handle_lifetime(args):
    paths = _get_paths(args.channel)
    if subprocess.run(["systemctl", "is-active", "--quiet",
                       f"ytlive-stream@{args.channel}.service"]).returncode != 0:
        handle_start(args)
    handle_unschedule(args, quiet=True)
    paths["lock"].write_text(LIFETIME_TAG)
    print_info(f"Stream '{args.channel}' diatur ke mode LIFETIME (permanen).")

def _internal_get_ffmpeg_cmd(args):
    paths = _get_paths(args.channel)
    mode = _get_channel_mode(paths)
    cmd = _build_ffmpeg_command(paths, mode)
    if not cmd:
        with open(paths["log"], "a") as f:
            f.write("ERROR: Gagal membangun perintah FFMPEG.\n")
        sys.exit(1)
    print(" ".join(shlex.quote(c) for c in cmd))

def main():
    parser = argparse.ArgumentParser(description="YTLive Streamer")
    subparsers = parser.add_subparsers(dest="command")
    subparsers.required = True

    handler_map = {
        "start": handle_start,
        "stop": handle_stop,
        "list": handle_list,
        "status": handle_status,
        "create": handle_create,
        "delete": handle_delete,
        "log": handle_log,
        "schedule": handle_schedule,
        "unschedule": handle_unschedule,
        "clean": handle_clean,
        "lifetime": handle_lifetime,
        "debug": handle_debug,
        "timer": handle_timers,
    }

    # Internal helper
    if len(sys.argv) > 1 and sys.argv[1].startswith("_internal"):
        internal = argparse.ArgumentParser()
        internal.add_argument("command")
        internal.add_argument("channel")
        a = internal.parse_args()
        if a.command == "_internal_get_ffmpeg_cmd":
            _internal_get_ffmpeg_cmd(a)
        return

    # Shortcut: ytlive <channel>
    if len(sys.argv) == 2 and sys.argv[1] not in handler_map and not sys.argv[1].startswith("-"):
        if (CHANNELS_DIR / sys.argv[1]).is_dir():
            sys.argv.insert(1, "status")
        else:
            print_error(f"Channel '{sys.argv[1]}' tidak ditemukan.")
            sys.exit(1)

    p = subparsers.add_parser("start");      p.add_argument("channel")
    p = subparsers.add_parser("stop");       p.add_argument("channel")
    subparsers.add_parser("list")
    subparsers.add_parser("timer")
    p = subparsers.add_parser("status");     p.add_argument("channel")
    p = subparsers.add_parser("create");     p.add_argument("channel")
    p = subparsers.add_parser("delete");     p.add_argument("channel")
    p = subparsers.add_parser("log");        p.add_argument("channel")
    p = subparsers.add_parser("debug");      p.add_argument("channel")
    p = subparsers.add_parser("schedule");   p.add_argument("channel"); p.add_argument("start_time"); p.add_argument("stop_time", nargs="?", default=None)
    p = subparsers.add_parser("unschedule"); p.add_argument("channel")
    p = subparsers.add_parser("clean");      p.add_argument("channel")
    p = subparsers.add_parser("lifetime");   p.add_argument("channel")

    for name, func in handler_map.items():
        if name in subparsers.choices:
            subparsers.choices[name].set_defaults(func=func)

    if len(sys.argv) == 1:
        parser.print_help()
        print("\n" + "="*20 + " STATUS CHANNEL SAAT INI " + "="*20)
        handle_list(None)
        sys.exit(0)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
EOF

chmod +x "${PYTHON_SCRIPT_PATH}" || log_error "Gagal membuat skrip Python dapat dieksekusi."

log_info "==================================================="
log_info "   YTLIVE STREAMER SETUP COMPLETE (v30 - STABIL)"
log_info "==================================================="
log_info "Gunakan: ytlive create <channel>, isi stream_key.txt,"
log_info "lalu ytlive lifetime <channel> atau ytlive start <channel>."
